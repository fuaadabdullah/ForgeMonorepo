name: ForgeTM Monitoring

on:
  schedule:
    # Run every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to monitor'
        required: true
        default: 'production'
        type: choice
        options:
          - staging
          - production
      check_type:
        description: 'Type of check to perform'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - health
          - performance
          - security

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/forge-backend

jobs:
  health-check:
    runs-on: ubuntu-latest
    if: inputs.check_type == 'all' || inputs.check_type == 'health'
    environment: ${{ inputs.environment || 'production' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Get service endpoint
        id: endpoint
        run: |
          if [ "${{ inputs.environment || 'production' }}" == "production" ]; then
            NAMESPACE="forge-production"
          else
            NAMESPACE="forge-staging"
          fi

          ENDPOINT=$(kubectl get svc forge-backend -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "endpoint=$ENDPOINT" >> $GITHUB_OUTPUT

      - name: Health check
        run: |
          ENDPOINT="${{ steps.endpoint.outputs.endpoint }}"

          # Basic health check
          if ! curl -f --max-time 30 http://$ENDPOINT/health; then
            echo "‚ùå Health check failed"
            exit 1
          fi

          # API endpoints check
          if ! curl -f --max-time 30 http://$ENDPOINT/api/v1/providers; then
            echo "‚ùå API endpoints check failed"
            exit 1
          fi

          # OpenAPI spec check
          if ! curl -f --max-time 30 http://$ENDPOINT/openapi.json; then
            echo "‚ùå OpenAPI spec check failed"
            exit 1
          fi

          echo "‚úÖ All health checks passed"

      - name: Check pod status
        run: |
          if [ "${{ inputs.environment || 'production' }}" == "production" ]; then
            NAMESPACE="forge-production"
          else
            NAMESPACE="forge-staging"
          fi

          # Check if pods are running
          kubectl get pods -n $NAMESPACE -l app=forge-backend

          # Check if all pods are ready
          READY_PODS=$(kubectl get pods -n $NAMESPACE -l app=forge-backend -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | grep -o "True" | wc -l)
          TOTAL_PODS=$(kubectl get pods -n $NAMESPACE -l app=forge-backend --no-headers | wc -l)

          if [ "$READY_PODS" -ne "$TOTAL_PODS" ]; then
            echo "‚ùå Not all pods are ready: $READY_PODS/$TOTAL_PODS"
            exit 1
          fi

          echo "‚úÖ All pods are ready: $READY_PODS/$TOTAL_PODS"

      - name: Notify health status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "## ‚úÖ Health Check Passed" >> $GITHUB_STEP_SUMMARY
            echo "- Environment: ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Endpoint: ${{ steps.endpoint.outputs.endpoint }}" >> $GITHUB_STEP_SUMMARY
            echo "- Status: All systems operational" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå Health Check Failed" >> $GITHUB_STEP_SUMMARY
            echo "- Environment: ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Endpoint: ${{ steps.endpoint.outputs.endpoint }}" >> $GITHUB_STEP_SUMMARY
            echo "- Status: Issues detected - check logs" >> $GITHUB_STEP_SUMMARY
          fi

  performance-check:
    runs-on: ubuntu-latest
    if: inputs.check_type == 'all' || inputs.check_type == 'performance'
    environment: ${{ inputs.environment || 'production' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Get service endpoint
        id: endpoint
        run: |
          if [ "${{ inputs.environment || 'production' }}" == "production" ]; then
            NAMESPACE="forge-production"
          else
            NAMESPACE="forge-staging"
          fi

          ENDPOINT=$(kubectl get svc forge-backend -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "endpoint=$ENDPOINT" >> $GITHUB_OUTPUT

      - name: Install k6
        run: |
          curl -fsSL https://deb.k6.io/key.gpg | sudo gpg --dearmor -o /usr/share/keyrings/k6-archive-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://deb.k6.io/ stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install -y k6

      - name: Run performance test
        run: |
          ENDPOINT="${{ steps.endpoint.outputs.endpoint }}"

          # Create performance test script
          cat > perf-test.js << EOF
          import http from 'k6/http';
          import { check, sleep } from 'k6';

          export let options = {
            stages: [
              { duration: '2m', target: 100 }, // Ramp up to 100 users
              { duration: '5m', target: 100 }, // Stay at 100 users
              { duration: '2m', target: 200 }, // Ramp up to 200 users
              { duration: '5m', target: 200 }, // Stay at 200 users
              { duration: '2m', target: 0 },   // Ramp down to 0 users
            ],
            thresholds: {
              http_req_duration: ['p(95)<1000', 'p(99)<2000'],
              http_req_failed: ['rate<0.05'],
            },
          };

          export default function () {
            let responses = http.batch([
              ['GET', \`http://\${__ENV.ENDPOINT}/health\`],
              ['GET', \`http://\${__ENV.ENDPOINT}/api/v1/providers\`],
            ]);

            responses.forEach(response => {
              check(response, {
                'status is 200': (r) => r.status === 200,
                'response time < 1000ms': (r) => r.timings.duration < 1000,
              });
            });

            sleep(Math.random() * 2 + 1); // Random sleep between 1-3 seconds
          }
          EOF

          # Run the test
          ENDPOINT=$ENDPOINT k6 run perf-test.js

      - name: Notify performance status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "## ‚úÖ Performance Check Passed" >> $GITHUB_STEP_SUMMARY
            echo "- Environment: ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Load Test: 200 concurrent users" >> $GITHUB_STEP_SUMMARY
            echo "- P95 Response Time: < 1000ms" >> $GITHUB_STEP_SUMMARY
            echo "- Error Rate: < 5%" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå Performance Check Failed" >> $GITHUB_STEP_SUMMARY
            echo "- Environment: ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Status: Performance degradation detected" >> $GITHUB_STEP_SUMMARY
          fi

  security-check:
    runs-on: ubuntu-latest
    if: inputs.check_type == 'all' || inputs.check_type == 'security'
    environment: ${{ inputs.environment || 'production' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Get current image
        id: image
        run: |
          if [ "${{ inputs.environment || 'production' }}" == "production" ]; then
            NAMESPACE="forge-production"
          else
            NAMESPACE="forge-staging"
          fi

          IMAGE=$(kubectl get deployment forge-backend -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}')
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

      - name: Install security tools
        run: |
          # Install Trivy
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin

          # Install Cosign
          curl -sSfL https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64 > /usr/local/bin/cosign
          chmod +x /usr/local/bin/cosign

      - name: Verify image signature
        run: |
          IMAGE="${{ steps.image.outputs.image }}"
          if ! cosign verify "$IMAGE" --certificate-identity-regexp ".*" --certificate-oidc-issuer-regexp ".*"; then
            echo "‚ùå Image signature verification failed"
            exit 1
          fi
          echo "‚úÖ Image signature verified"

      - name: Scan for vulnerabilities
        run: |
          IMAGE="${{ steps.image.outputs.image }}"
          if ! trivy image --exit-code 1 --severity HIGH,CRITICAL "$IMAGE"; then
            echo "‚ùå High/Critical vulnerabilities found"
            exit 1
          fi
          echo "‚úÖ No high/critical vulnerabilities found"

      - name: Check for secrets in environment
        run: |
          # Install ggshield
          pip install ggshield

          # Check for secrets in environment variables
          if [ "${{ inputs.environment || 'production' }}" == "production" ]; then
            NAMESPACE="forge-production"
          else
            NAMESPACE="forge-staging"
          fi

          # Get environment variables from deployment
          kubectl get configmap -n $NAMESPACE -o yaml > configmap.yaml
          kubectl get secret -n $NAMESPACE -o yaml > secret.yaml

          # Check for hardcoded secrets
          if ggshield secret scan configmap.yaml secret.yaml; then
            echo "‚ùå Potential secrets found in configuration"
            exit 1
          fi

          echo "‚úÖ No secrets detected in configuration"

      - name: Notify security status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "## ‚úÖ Security Check Passed" >> $GITHUB_STEP_SUMMARY
            echo "- Environment: ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Image Signature: ‚úÖ Verified" >> $GITHUB_STEP_SUMMARY
            echo "- Vulnerabilities: ‚úÖ No high/critical issues" >> $GITHUB_STEP_SUMMARY
            echo "- Secrets: ‚úÖ No exposed secrets" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ‚ùå Security Check Failed" >> $GITHUB_STEP_SUMMARY
            echo "- Environment: ${{ inputs.environment || 'production' }}" >> $GITHUB_STEP_SUMMARY
            echo "- Status: Security issues detected" >> $GITHUB_STEP_SUMMARY
          fi

  alert-on-failure:
    runs-on: ubuntu-latest
    needs: [health-check, performance-check, security-check]
    if: failure()
    steps:
      - name: Create issue on failure
        run: |
          # This would integrate with your alerting system
          # For now, we'll create a GitHub issue
          TITLE="üî¥ Monitoring Alert: ${{ inputs.environment || 'production' }} Environment Issues"
          BODY="## Monitoring Alert

          Environment: ${{ inputs.environment || 'production' }}
          Timestamp: $(date -u)

          ### Failed Checks:
          $([ "${{ needs.health-check.result }}" == "failure" ] && echo "- ‚ùå Health Check")
          $([ "${{ needs.performance-check.result }}" == "failure" ] && echo "- ‚ùå Performance Check")
          $([ "${{ needs.security-check.result }}" == "failure" ] && echo "- ‚ùå Security Check")

          ### Actions Required:
          1. Check application logs
          2. Review recent deployments
          3. Investigate failing checks
          4. Consider rollback if necessary

          [View Workflow Run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"

          # Create GitHub issue (requires GITHUB_TOKEN with issues permission)
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            https://api.github.com/repos/${{ github.repository }}/issues \
            -d "{\"title\":\"$TITLE\",\"body\":\"$BODY\",\"labels\":[\"monitoring\",\"alert\"]}"
